clear all
close all
clc

tex = imread('tex.jpg');

% 1. read the image black and white
image = im2gray(tex);
[M,N] = size(image);

% define a series of patterns, all 14x14
R = 14;
C = 14;
patterns = {
    image(1:R, 1:C), ...
    image(2:R+1, 2:C+1), ...
    image(M-13:M, N-13:N), ...
    image(M-14:M-1, N-14:N-1), ...
    image(1:R, N-13:N), ...
    image(2:R+1, N-13:N)
};

% visualize the patterns on the original image (in the corners of the image)
figure;
imagesc(image); axis image; colormap gray; hold on;
title ('patterns')
rectangle('position',[1,1,R,C],'EdgeColor','r'); % pattern1
rectangle('position',[2,2,R,C],'EdgeColor','g'); % pattern2
rectangle('position',[M-13,N-13,14,14],'EdgeColor','b'); % pattern3
rectangle('position',[M-14,N-14,14,14],'EdgeColor','c'); % pattern4
rectangle('position',[1,N-13,14,14],'EdgeColor','m'); % pattern5
rectangle('position',[2,N-13,14,14],'EdgeColor','k'); % pattern6

threshold = 0.2;

% iterate over each pattern
totalCorrelation = []; % initialize as empty, will be sized on first iteration
for i = 1:length(patterns)
    pattern = patterns{i};
    [R, C] = size(pattern);
    temp = normxcorr2(pattern, image);
    
    if i == 1
        % first iteration: initialize totalCorrelation with the size of temp
        totalCorrelation = temp;
    else
        % subsequent iterations: add the correlation matrix
        totalCorrelation = totalCorrelation + temp;
    end
end

% calculate the mean correlation
correlation = totalCorrelation / length(patterns);

% Consider only the part of the cross-correlation that was performed without 
% the zero-padded edges, in order to remove the border effect.
% Thus, the output will have dimensions (M-R+1, N-C+1) -> [499;499]
% (R:end-R+1,C:end-C+1) : cut this piece out and keep only the "inside"
correlation = correlation(R:end-R+1,C:end-C+1); % it cuts the edges off the cross-correlation matrix

% Visualize, in a subplot with two panels, the absolute value of the
% cross-correlation just estimated

% surface plot
% figure, subplot(121), surf(abs(correlation)), shading flat
% title ('Xcorr2D - Surface Plot')

% image graph
figure, imagesc(abs(correlation)), axis, 'image'; colorbar
title ('Xcorr2D - Immagine')

% I do abs for search all the lows values, not influenced by the sign
correlation = abs(correlation);

% applay a threshold to the cross-correlation matrix to create a binary/logical mask,
% to select a certain range of values, and then visualize it
mask = correlation < threshold;
figure, imagesc(mask)
title ('mask 1')

% we use this tool to highlight the points "large enough", in this case big 3,
% in the previus mask and then create a second mask
se = strel('disk', 3);  % create a disk of radius 3
mask2 = imopen(mask, se);
figure, imagesc(mask2);
title ('mask 2 [morphological operation]')

% NOTE : the masks contain logical values to identify the different values(0, 1)

% modify the starting image in black and white so that it has dimensions
% equal to the cross-correlation matrix, for matching the dimension of the masks
image = image(ceil(R/2):end-floor(R/2), ceil(C/2):end-floor(C/2));  % [499;499]

% create a new image, equal to the original image, but the pixels that are equal to 1
% in the variable mask2 should be set to 255 tempImage;
% this increases the color of the highlighted region,
% making the color of the area completely white(255), so in other words
% the pixels in tempImage that correspond to true(1) values in mask2 are set to 255
tempImage = image;
tempImage(mask2) = 255;

% visualize alongside image, and the image with the defect highlighted in red
% create a final RGB image, where with the function cat() we indicate the
% colors of the image;
% we use tempImage first, because we paste the values with all white, so
% 255 , in the red channel, 
finalImage = cat(3, tempImage, image, image);
figure;
imshowpair(image, finalImage, 'montage')
title ('Immagine e Difetto finale')